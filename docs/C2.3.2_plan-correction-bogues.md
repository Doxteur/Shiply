## Plan de correction des bogues (C2.3.2)

### 1) Détection
Sources de signalement et premiers indices:
- UI: erreurs visibles (toasts), pages qui ne chargent pas, comportements inattendus.
- API: logs structurés (niveau error), route concernée, statut HTTP, stacktrace.
- Runner: logs d’exécution, échec de conteneur Docker, cancellation.
- CI: échecs de tests, lint/typecheck, scans sécurité (Trivy/ZAP), qualité (Lighthouse/Sonar).

### 2) Qualification & priorisation
Avant toute modification de code, le bug doit être qualifié. L’objectif est de comprendre précisément le probleme, valider qu’il est reproductible et mesurer son impact. Cette étape guide le choix entre un hotfix (si production réellement impactée) et une correction standard sur develop.

Étapes de qualification:
- Reproduire le bug de manière fiable et noter l’environnement concerné (dev, staging, prod), la version/tag,la route API.
- Collecter les éléments : logs API/runner, messages UI, contexte Docker (runner), entrées utilisateur.
- Évaluer la gravité et l’impact:
  - Critique: service ou production KO, fuite de données, corruption.
  - Majeure: fonctionnalité dégradée, contournement possible.
  - Mineure: cosmétique, wording, défaut UX mineur.
- Cartographier le périmètre probable: composant UI, endpoint API, runner, dépendances (Docker, GitHub), config.
- Triage: assigner le ticket, estimer l’effort, décider du canal (hotfix vs fix) et de l’échéance.

### 3) Voies de correction
Deux cas typiques selon l’impact:
- Critique en production → Hotfix GitFlow depuis `main`.
- Défaut sur develop/staging → Correction standard depuis `develop`.

Branche & conventions:
- Nommage: `hotfix/<slug-bug>` ou `fix/<area>-<slug>`.
- Commits Conventional Commits: `fix(api):`, `fix(ui):`, etc.
- TypeScript strict, pas de any non justifié.

Tests à fournir:
- Test unitaire ciblé qui échouait auparavant.
- Test de non‑régression si le défaut touchait une zone critique.
- UI: test RTL/axe si composant modifié.


### 4) Validation PR (gates qualité)
Conditions d’acceptation d’un correctif:
- CI OK: typecheck, lint, tests unitaires.
- Couverture ≥ 80% sur les fichiers touchés (ou justification en review).
- Pour l’UI: audit axe (a11y) si composant modifié, pas de régression visuelle évidente.
- Revue par pair; changelog mis à jour au plus tard en release.

### 5) Déploiement & vérification
Staging puis production:
- Tirer les images et redémarrer via Docker Compose (voir manuel C2.4.1):
```
docker compose -f docker-compose.prod.yml pull
docker compose -f docker-compose.prod.yml up -d --remove-orphans
docker exec -it shiply-api-prod node ace migration:run --force  # si migration
curl -f http://localhost:12001/health || exit 1
```
- Vérifier le correctif in situ: scenario de repro devenu OK, logs propres, pas d’effet de bord.

### 6) Rollback (si nécessaire)
Référer au manuel de déploiement C2.4.1. En bref:
- Pinner le tag précédent dans `docker-compose.prod.yml` et relancer `pull` + `up -d`.
- Si des migrations ont été passées, envisager `migration:rollback` sur l’API.
- Documenter l’incident et ouvrir un ticket de suivi si cas non résolue.

### 7) Prévention
Objectifs: supprimer la cause racine et éviter la réapparition.
- Actions préventives: ajouter tests manquants, renforcer validation (types, schémas), feature flags si risque.
- Documentation: compléter les manuels/README, notes de release, changelog.

Checklist PR de correctif:
- [ ] Lint/typecheck OK
- [ ] Tests ajoutés/mis à jour (≥ 80% sur fichiers touchés)
- [ ] A11y (axe) si UI
- [ ] Changelog/Docs si nécessaire
- [ ] Revue approuvée
